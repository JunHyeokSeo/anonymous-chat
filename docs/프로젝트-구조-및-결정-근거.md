# 프로젝트 구조 및 결정 근거

## 1. 아키텍처: 계층형 아키텍처 (Layered Architecture)

본 프로젝트는 시스템의 복잡성을 관리하고, 유지보수성과 테스트 용이성을 높이기 위해 계층형 아키텍처를 채택했습니다. 각 계층은 명확히 정의된 책임을 가지며, 의존성 규칙(상위 계층은 하위 계층에만 의존)을 엄격히 따릅니다.

### 1.1. 계층 구조

- **Presentation (표현 계층)**
  - **책임**: 외부 세계와의 인터페이스. HTTP 요청 처리(REST API), WebSocket 통신, 사용자 인터페이스 렌더링(HTML)을 담당합니다.
  - **구성 요소**: `@RestController`, `@Controller`, `@WebSocketHandler`, DTOs (Data Transfer Objects)
  - **결정 근거**: 외부의 요구사항 변경(예: API 스펙 변경, UI 개편)이 비즈니스 로직에 직접적인 영향을 미치지 않도록 격리합니다. DTO를 사용하여 계층 간 데이터 전송을 명확히 하고, 각 계층에 필요한 데이터만 노출합니다.

- **Application (애플리케이션 계층)**
  - **책임**: 시스템이 제공하는 기능, 즉 유스케이스(Use Case)를 정의하고 구현합니다. 비즈니스 로직의 흐름을 조정하며, 여러 도메인 서비스나 리포지토리를 조합하여 하나의 완전한 기능을 완성합니다.
  - **구성 요소**: `@UseCase` (커스텀 어노테이션), `@Service`
  - **결정 근거**: `@UseCase`와 `@Service`를 분리하여, 사용자 시나리오에 가까운 큰 단위의 비즈니스 흐름(UseCase)과 재사용 가능한 세부 비즈니스 로직(Service)을 구분했습니다. 이를 통해 코드의 가독성과 재사용성을 높였습니다.

- **Domain (도메인 계층)**
  - **책임**: 시스템의 핵심 비즈니스 규칙과 데이터를 표현합니다. 외부 기술에 의존하지 않는 순수한 비즈니스 로직의 집합입니다.
  - **구성 요소**: `@Entity`, Repository Interfaces, Enums (Type)
  - **결정 근거**: 도메인 모델을 시스템의 중심에 둠으로써, 비즈니스의 본질적인 복잡성에 집중할 수 있습니다. 인프라스트럭처의 변화로부터 도메인 로직을 보호하여 시스템의 안정성을 확보합니다.

- **Infrastructure (인프라스트럭처 계층)**
  - **책임**: 데이터베이스 연동, 외부 API 호출, 메시징, 파일 시스템 등 기술적인 세부 사항을 구현합니다.
  - **구성 요소**: JPA Repository Implementations (QueryDSL), Redis-based Adapters, JWT Providers, File Storage Implementations
  - **결정 근거**: 기술 종속적인 코드를 이 계층에 집중시켜, 다른 계층(특히 Domain)이 특정 기술(예: JPA, Redis)에 종속되지 않도록 합니다. 향후 기술 스택을 변경해야 할 경우, 이 계층의 수정만으로 대응할 수 있어 유연성이 증대됩니다.

## 2. 기술 스택 결정 근거

- **Spring Boot**: Java 생태계에서 가장 생산성이 높은 프레임워크로, 내장 WAS, 자동 설정, 방대한 라이브러리 지원을 통해 빠르게 안정적인 애플리케이션을 구축할 수 있어 채택했습니다.

- **Spring WebSocket**: 실시간 채팅 기능을 구현하기 위해 표준 기술인 WebSocket을 채택했으며, Spring은 STOMP 등 고수준 프로토콜 없이도 유연하게 핸들러를 구현할 수 있는 기능을 제공하여 선택했습니다.

- **Spring Security / JWT / OAuth2**: 인증/인가 구현을 위해 표준적인 Spring Security를 사용했습니다. 상태 비저장(Stateless) 아키텍처를 위해 JWT를 채택하여 서버 확장성을 확보했으며, 소셜 로그인의 편리함을 제공하기 위해 OAuth2를 도입했습니다.

- **JPA & QueryDSL**: 데이터베이스와의 상호작용을 객체 지향적으로 처리하기 위해 JPA를 사용했습니다. 복잡한 동적 쿼리 작성을 위해 컴파일 시점에 타입 체크가 가능한 QueryDSL을 조합하여 코드의 안정성과 생산성을 높였습니다.

- **Redis**: Refresh Token 저장, Access Token 블랙리스트 관리 등 인증 관련 데이터를 효율적으로 관리하기 위해 인메모리 데이터 저장소인 Redis를 채택했습니다. 빠른 속도와 TTL(Time-To-Live) 기능을 활용하여 상태 기반 데이터를 효과적으로 처리합니다.

- **Mermaid (문서화)**: 다이어그램을 텍스트 기반으로 작성하고 버전 관리가 가능하게 하여, 문서와 코드의 정합성을 유지하기 용이하므로 채택했습니다.
